snippet #!
abbr    #!/usr/bin/env stack ...
	#!/usr/bin/env stack
	{- stack script
		--resolver ${1:lts-18.5}
		--package aeson
		--package bytestring
		--package cassava
		--package containers
		--package directory
		--package lens
		--package process
		--package temporary
		--package text
		--package unordered-containers
		--package vector
		--package vector-algorithms
		--package wreq
		--package ${2:turtle}
		--
	-}
	
	--{-# LANGUAGE GHC2021 #-}
	{-# LANGUAGE ApplicativeDo #-}
	{-# LANGUAGE BlockArguments #-}
	{-# LANGUAGE DataKinds #-}
	{-# LANGUAGE DefaultSignatures #-}
	{-# LANGUAGE DeriveAnyClass #-}
	{-# LANGUAGE DeriveFoldable #-}
	{-# LANGUAGE DeriveFunctor #-}
	{-# LANGUAGE DeriveGeneric #-}
	{-# LANGUAGE DeriveTraversable #-}
	{-# LANGUAGE DerivingStrategies #-}
	{-# LANGUAGE DerivingVia #-}
	{-# LANGUAGE DuplicateRecordFields #-}
	{-# LANGUAGE FlexibleContexts #-}
	{-# LANGUAGE FlexibleInstances #-}
	{-# LANGUAGE GeneralizedNewtypeDeriving #-}
	{-# LANGUAGE InstanceSigs #-}
	{-# LANGUAGE KindSignatures #-}
	{-# LANGUAGE LambdaCase #-}
	{-# LANGUAGE MultiParamTypeClasses #-}
	{-# LANGUAGE MultiWayIf #-}
	{-# LANGUAGE NamedFieldPuns #-}
	{-# LANGUAGE NoImplicitPrelude #-}
	{-# LANGUAGE NumericUnderscores #-}
	{-# LANGUAGE OverloadedStrings #-}
	{-# LANGUAGE PolyKinds #-}
	{-# LANGUAGE RankNTypes #-}
	{-# LANGUAGE RecordWildCards #-}
	{-# LANGUAGE ScopedTypeVariables #-}
	{-# LANGUAGE StandaloneDeriving #-}
	-- {-# LANGUAGE StandaloneKindSignatures #-}
	{-# LANGUAGE StrictData #-}
	{-# LANGUAGE TupleSections #-}
	{-# LANGUAGE TypeApplications #-}
	{-# LANGUAGE TypeFamilies #-}
	{-# LANGUAGE TypeOperators #-}
	{-# LANGUAGE ViewPatterns #-}
	
	{-# OPTIONS_GHC
		-Wall
		-Wcompat
		-Wimplicit-prelude
		-Wincomplete-record-updates
		-Wpartial-fields
		-Wmissing-deriving-strategies
		-Wredundant-record-wildcards
		-Wunused-packages
		-Wunused-record-wildcards
	  #-}
	
	moduleMain${0}

snippet lang
	{-# LANGUAGE ${0:OverloadedStrings} #-}

snippet langStrictData
	{-# LANGUAGE StrictData #-}

snippet langDataKinds
	{-# LANGUAGE DataKinds #-}

snippet langNoImplicitPrelude
	{-# LANGUAGE NoImplicitPrelude #-}

snippet langRankNTypes
	{-# LANGUAGE RankNTypes #-}

snippet langTypeOperators
	{-# LANGUAGE TypeOperators #-}

snippet langDuplicateRecordFields
	{-# LANGUAGE DuplicateRecordFields #-}

snippet langTemplateHaskell
abbr    {-# LANGUAGE TemplateHaskell #-}
	{-# LANGUAGE TemplateHaskell #-}

snippet haddock
	{-# OPTIONS_HADDOCK ${0:hide} #-}

snippet ghc
snippet {-# OPTIONS_GHC ...
	{-# OPTIONS_GHC ${0:-Wno-unused-imports -Wno-orphans} #-}

snippet inline
abbr    {-# INLINE ...
	{-# INLINE ${0:name} #-}

snippet imp
abbr    import Data.Text
	import ${0:Data.Text}

snippet imp2
abbr    import Data.Text (Text)
	import ${1:Data.Text} (${0:Text})

snippet impq
abbr    import qualified Data.Text as Text
	import qualified ${1:Data.Text} as ${0:Text}

snippet impEq
abbr    import Data.Eq
	import Data.Eq (Eq${1:, (==)}${2:, (/=)})${0}

snippet impApplicative
abbr    import Control.Applicative
	import Control.Applicative (${1:(*>), (<*>), pure})${0}

snippet impMonad
abbr    import Control.Monad
	import Control.Monad (${1:when, unless})${0}

snippet impMonadIO
abbr    import Control.Monad.IO.Class
	import Control.Monad.IO.Class (${1:MonadIO, liftIO})${0}

snippet impFunction
abbr    import Data.Function
	import Data.Function (${1:($), }${2:(&), }${3:(.), }${4:const, flip, id, on})${0}

snippet impFunctor
abbr    import Data.Functor
	import Data.Functor (${1:Functor, }${2:($>), (<$), }${3:(<$>)}${4:, (<&>), fmap, void})${0}

snippet impOrd
abbr    import Data.Ord
	import Data.Ord (Ord${1:, (<)}${2:, (<=)}${3:, (>)}${4:, (>=)})${0}

snippet impGenerics
abbr    import GHC.Generic
	import GHC.Generic (Generic)${0}

snippet impProxy
abbr    import Data.Proxy
	import Data.Proxy (Proxy${1:(Proxy)})${0}

snippet impPrelude
abbr    import Prelude
	import Prelude${0: (Bounded(..), Enum, error, fromIntegral, undefined)}

snippet inst
snippet instance Class Type ...
	instance ${1:Monoid} ${2:Type} where
		${0}

snippet instSemigroup
abbr    instance Semigroup ...
	instance ${1:Semigroup a => }Semigroup ${2:Type} where
		(<>) :: $2 -> $2 -> $2
		${0}

snippet instMonoid
abbr    instance Semigroup ...
	instance ${1:Monoid a => }Monoid ${2:Type} where
		mappend :: $2
		mappend = ${0}

snippet type
abbr    type TypeAlias = Type
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	type ${1:Type} = ${0:Type}

snippet typeFamily
abbr    type family Family ...
	type family ${1:Type} ${0}

snippet typeInstance
abbr    type instance Family ...
	type instance ${1:Type} ${2:TypeArg} = ${0}

snippet data
abbr    data TypeCon = Con
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	data ${1:Type} = ${0:$1}
	  deriving stock (Eq, Generic, Show)

snippet dataFamily
abbr    data family Family ...
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	data family ${1:Type} ${0}

snippet newtype
abbr    newtype TypeCon = Con Type
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	newtype ${1:Type} = ${2:$1} ${0:Int}
	  deriving stock (Generic, Show)
	  deriving newtype (Eq, Ord)

snippet newtypeRec
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
abbr    newtype TypeCon = Con {selector :: Type}
	newtype ${1:Type} = ${2:$1}
		{ ${3:selector} :: ${0:Int}
		}
	  deriving stock (Generic, Show)
	  deriving newtype (Eq, Ord)

snippet newtypeIdentityT
abbr    newtype TypeCon m a = Con (m a)
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	newtype ${1:Type} m a = ${2:$1} (${0:m a})
	  deriving newtype (Applicative, Functor, Monad, MonadIO)

snippet class
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	class ${1:Class} ${2:a} where
		${0}

snippet info
abbr    -- | Module: ...
	-- |
	-- Module:      ${1:`substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')`}
	-- Description: ${2:TODO: Module synopsis}
	-- Copyright:   (c) ${3:`strftime('%Y')`} ${4:Peter Trško}
	-- License:     ${5:BSD3}
	--
	-- Maintainer:  ${6:peter.trsko@gmail.com}
	-- Stability:   ${7:experimental}
	-- Portability: ${8:GHC specific language extensions}${9:; POSIX}.
	--
	-- ${0:TODO: Module description.}

snippet module
abbr    module Module ...
	-- |
	-- Module:      ${1:`substitute(substitute(expand('%:r'), '[/\\]','.','g'),'^\%(\l*\.\)\?','','')`}
	-- Description: ${2:TODO: Module synopsis}
	-- Copyright:   (c) ${3:`strftime('%Y')`} ${4:Peter Trško}
	-- License:     ${5:BSD3}
	--
	-- Maintainer:  ${6:peter.trsko@gmail.com}
	-- Stability:   ${7:experimental}
	-- Portability: ${8:GHC specific language extensions}${9:; POSIX}.
	--
	-- ${10:TODO: Module description.}
	module $1
	--  (`expand('%') =~ 'Main' ? " main" : ""`
	--  )
	  where
	`expand('%') =~ 'Main' ? "\nimport System.IO (IO)\n\nmain :: IO ()\nmain = " : ""`${0}

snippet moduleMain
abbr    module Main ...
	-- |
	-- Module:      Main
	-- Description: ${1:TODO: Module synopsis}
	-- Copyright:   (c) ${2:`strftime('%Y')`} ${3:Peter Trško}
	-- License:     ${4:BSD3}
	--
	-- Maintainer:  ${5:peter.trsko@gmail.com}
	-- Stability:   ${6:experimental}
	-- Portability: ${7:GHC specific language extensions}${8:; POSIX}.
	--
	-- ${9:TODO: Module description.}
	module Main
	    ( main
	    )
	  where
	
	import Prelude
	import System.IO (IO)
	
	
	main :: IO ()
	main = ${0}

snippet main1
	main :: IO ()
	main = ${0:undefined}

snippet main2
	main :: IO ()
	main = do
		${0:undefined}

snippet def
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	${1:name} :: ${2:a}
	$1 = ${0:undefined}

snippet fn
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	${1:fn} :: ${2:a} -> ${3:a}
	$1 ${4:_} = ${0:undefined}

snippet fn2
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	${1:fn} :: ${2:a} -> ${3:a} -> ${4:a}
	$1 ${5:_ _} = ${0:undefined}

snippet fn3
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	${1:fn} :: ${2:a} -> ${3:a} -> ${4:a} -> ${5:a}
	$1 ${6:_ _ _} = ${0:undefined}

snippet =>
	(${1:Class} ${2:a}) => $2 -> ${0}

snippet =>2
	(${1:Class1} ${2:a}, ${3:Class2} $2) => $2 -> ${0}

snippet for
abbr    for container \element -> do
	for ${1:container} \\${2:element} -> do
		${0}

snippet for_
abbr    for_ container \element -> do
	for_ ${1:container} \\${2:element} -> do
		${0}

snippet when
abbr    when (condition) do
	when (${2:condition}) do
		${0}

snippet unless
abbr    unless (condition) do
	${1:when} (${2:condition}) do
		${0}

snippet guard
abbr    r <$ guard (condition)
	${1:r} <$ guard (${0:condition})

snippet void
alias   _do
abbr    void do
	void do
		${0}

snippet <$
	${1:r} <$ do
		${0:expression}

snippet &\
	${1:x} & \\${2:Record\{..\}} ->
		${0:expression}

snippet <&>\
alias   <&\
	${1:x} <&> \\${2:Record\{..\}} ->
		${0:expression}

snippet \
	\\${1:x} -> ${0:expression}

snippet \(
	\\(${1:x}) -> ${0:expression}

snippet guard
abbr    r <$ guard (condition)
	${1:r} <$ guard (${0:condition})

snippet \do
	\\${1:x} -> do
		${0:expression}

snippet (\
	(\\${1:x} -> ${0:expression})

snippet <-
	${1:a} <- ${0:m a}

snippet <-do
abbr    r <- do
	${1:r} <- do
		${0}

snippet ->
abbr    pattern -> expression
	${1:Pattern} -> ${0:expression}

snippet tup
alias   tup2
abbr    (a, b)
	(${1:a}, ${0:b})

snippet tup3
abbr    (a, b, c)
	(${1:a}, ${2:b}, ${0:c})

snippet tup4
abbr    (a, b, c, d)
	(${1:a}, ${2:b}, ${3:c}, ${0:d})

snippet enum
abbr    data Enum = V1 | V2 | ...
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	data ${1:Enum}
		= ${2:Value1}
		-- ^ TODO: Describe '$2'.
		| ${3:Value2}
		-- ^ TODO: Describe '$3'.
		| ${4:Value3}
		-- ^ TODO: Describe '$4'.
	  deriving stock (Bounded, Enum, Eq, Ord, Generic, Show)

snippet rec
abbr    data Rec = Rec { ...
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	data ${1:Record} = ${2:$1}
		{ ${3:fieldA} :: ${4:Text}
		-- ^ TODO: Describe @$3@.
		, ${5:fieldB} :: ${0:Text}
		-- ^ TODO: Describe @$5@.
		${0}
		}
	  deriving stock (Eq, Ord, Generic, Show)

snippet con
abbr    | Con
	| ${1:Constructor}
	-- ^ TODO: Describe '$1'
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	${0}

snippet recCon
abbr    | Con { ...
	-- | TODO: Describe '$1'.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	| ${1:Record}
		{ ${2:fieldA} :: ${3:Text}
		-- ^ TODO: Describe '$2'.
		, ${4:fieldB} :: ${0:Text}
		-- ^ TODO: Describe '$4'.
		}

snippet recField
abbr    , field :: Type
	, ${1:field} :: ${2:Text}
	-- ^ TODO: Describe @$1@.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	${0}

snippet setField
abbr    , field = value
	, ${1:field} = ${2:value}
	${0}

snippet set
abbr    field = value
	${1:field} = ${2:value}
	${0}

snippet recVal1
	${1:Record}{${2:fieldA} = ${0:undefined}}

snippet recVal2
	${1:Record}
		{ ${2:fieldA} = ${3:undefined}
		, ${4:fieldB} = ${0:undefined}
		}

snippet pureRec
abbr    pure Record{..}
	pure ${1:Record}${0:\{..\}}

snippet case
	case ${1:something} of
		${2} -> ${0}

snippet let
	let ${1} = ${2}

snippet let1
	let ${1} = ${2}
	in ${3}

snippet let2
	let ${1:x} = ${2:undefined}
		${3:y} = ${4:undefined}
	in ${0}

snippet where
	where
	  ${1:fn} = ${0:undefined}

snippet der
abbr    deriving stock|newtype|anyclass (...)
	deriving ${1:stock newtype anyclass} (${0:Eq, Generic, Show})

snippet derStock
abbr    deriving stock (...)
	deriving stock (${0:Eq, Ord, Generic, Show})

snippet derNewtype
abbr    deriving newtype (...)
	deriving newtype (${0:Eq, Ord})

snippet derVia
abbr    deriving (...) via (...)
	deriving (${1}) via (${0})

snippet \c
abbr    \case
	\case
		${1:_} -> ${0:undefined}

snippet tastyMain
abbr    main = Test.Tasty.defaultMain ...
	-- |
	-- Module:      Main
	-- Description: Unit tests for ${1:TODO: synopsis}
	-- Copyright:   (c) ${2:`strftime('%Y')`} ${3:Peter Trško}
	-- License:     ${4:BSD3}
	--
	-- Maintainer:  ${5:peter.trsko@gmail.com}
	-- Stability:   ${6:experimental}
	-- Portability: ${7:GHC specific language extensions}${8:; POSIX}.
	--
	-- Unit tests for ${9:TODO: description}
	module Main
	    ( main
	    )
	  where
	
	import Prelude
	
	import Test.QuickCheck.Instances ()
	import Test.Tasty (TestName, TestTree, defaultMain, testGroup)
	import Test.Tasty.HUnit as Tasty (assertFailure, testCase)
	import Test.Tasty.QuickCheck (counterexample, testProperty)
	
	
	main :: IO ()
	main = defaultMain $ testGroup "Tests" tests

	tests :: [TestTree]
	tests =
		[ testCase "A Test" do
			assertFailure "TODO: Test something"
		, testProperty "A Property"
			$ counterexample "TODO: Test something" False
		]

snippet tastyCase
abbr    testCase "name" do
	testCase "${1:A test case name}" do
		${0}

snippet tastyProperty
abbr    testProperty "name" \x -> ...
	testProperty "${1:A property name}" \\${2:(n :: Int)} ->
		${0}

snippet parseJSON
abbr    instance FromJSON ...
	-- | TODO: Describe.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	instance FromJSON ${1:Something} where
		parseJSON :: Aeson.Value -> Aeson.Parser $1
		parseJSON = Aeson.withObject "$1" \o -> do
			${2:field} <- o .: "$2"
			${0}
			pure $1{..}

snippet toJSON
abbr    instance ToJSON ...
	-- | TODO: Describe.
	--
	-- @since MAJOR1.MAJOR2.MINOR.PATCH
	instance ToJSON ${1:Something} where
		toJSON :: $1 -> Aeson.Value
		toJSON $1{..} = Aeson.object
			[ "${2:field}" .= $2
			, ${0}
			]
		
		toEncoding :: $1 -> Aeson.Encoding
		toEncoding $1{..} = Aeson.pairs
			"$2" .= $2
			<> $0
